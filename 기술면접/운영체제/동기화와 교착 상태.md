# 동기화와 교착 상태

**공유자원(Shared Resource)란 프로세스 혹은 스레드가 공유하고 있는 자원으로 메모리나 파일/ **전역 변수나 입출력장치**일수도 있음

- if 공유자원을 두고, 다수의 프로세스, 스레드가 동시에 공유 자원을 접근할 경우 문제가 생길 수도 있음.

- **임계 구역(critical section)** = 공유자원에 접근하는 코드 중, 동시에 실행했을 때, 문제가 발생할 수 있는 코드 -> 동시에 실행되는 프로세스, 스레드가 동시에 임계 구역에 진입하여 실행되면 문제. 

- A와 B가 있을 때, A가 공유자원에 쓰고, B가 읽으면 문제가 되지 않지만, B가 읽고, A가 쓰게 된다면, 문제가 되기에 critical section이라고 봄.
- 작업내용이 반영되지 않은 채, 읽기를 실행하는 것이 문제.
- 각 스레드가 파일을 수정하는 코드도 critical section 임

Race condition = 프로세스 혹은 스레드가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 상황
(그렇기에 동시에 임계 구역을 실행하지 않도록 유의해야 함)
- race condition 발생하면, **일관성**을 손상시키기에, 하나가 실행 중이면 하나는 대기해야 함.

레이스 컨디션이 발생하는 실행 흐름
os/race.c
```
#include <stdio.h>
#include <pthread.h>

int shared_data = 0

void* increment(void *args) {
 int i;
 for(i=0; i<10000; i++ ){
	shared_data ++ l
}
return NULL;
}

void* decrement(void *args) {
int i;
for (i= 0; i <10000; i ++ ) {
shared_data --;
}
return NULL;
}

int main(){
pthread_t thread1, thread2;

pthread_create(&thread1, NULL, increment, NULL);
pthread_create(&thread2, NULL, decrement, NULL);

pthread_joi(thread1, NULL);
pthread_join(thread2, NULL);

printf(shared data);
return 0 ;
```
0으로 결과가 출력되는 것이 아닌, race condition이 발생하면서 결과값이 달라진다.

race condition을 방지 + critical section을 관리하기 위해서는 **프로세스와 스레드가 동기화**되어야 한다. 이에 2가지 조건 중 하나가 준수되면서 실행되는 것이다. 
1. 실행 순서 제어 : 프로세스 및 스레드를 올바른 순서로 실행하기
2. **상호 배제** : 동시에 접근해서는 안되는 자언에 하나의 프로세스 및 스레드만 접근하도록 함(mutual exclusion)

## 동기화 기법

### mutex lock

mutext lock이란 동시에 접근하면 안되는 자원에 동시 접근이 불가능하도록 mutual exclution을 보장하는 동기화 도구이다. (mutex lock = mutual exclusion을 위한 lock)

mutex lock의 원리

임계 구역에 접근하고자 한다면 반드시 lock을 통해서 acquire해야 하고, 임계 구역에서의 작업이 끝났다면 lock을 release 해야 한다.

mutexx lock의 구현

프로세스 및 스레드가 공유하는 lock + 2개의 함수(acquire, release)로 구현된다. 
- 임계 구역에 전입을 위해서 공유하는 락을 획득: lock.acquire() 호출
- 다른 프로세스나 스레드가 lock.aquire() 호출하더라도 lock 획득은 불가능, lock이 해제될 때까지 대기
- 임계 구역의 작업이 끝나면 lock.release() 호출
- 대기하는 프로세스 또는 스레드가 lock.acquire() 호출, 임계 구역 진입


mutex lock을 추가한 java mutex code
```
public class Mutex {
static it sharedData = 0;
**static Lock lock = new ReentrantLock() ** //lock 선언
public static void main(String[] args) {
Thread t1 = new Thread(new Increment());
THread t2 = new Thread(new decrement());

t1.start();
t2.start();

try {
t1.join();
t2.join()
}catch ( InterruptedException e ) {
e.printStackTrace();
}

Sysout(sharedData) ;

}

static class Increment implements Runnable {
public void run(){
for (int i = 0; i <10000 ; i ++ ) {
lock. lock() // 락 획득
try{
sharedData ++;
}
finally {
lock.unlock();
}
}}}}

static class decrement implements Runnable {
public void run(){
for (int i = 0; i < 10000; i ++ ) {
lock.lock();
try{
sharedData -- ;
}
finally {
lock.unlock() ;
}}}}
```

하지만, mutex lock은 하나의 자원만 고려한 동기화 도구

### Semaphore

프로세스 및 스레드가 임계 구역 앞에서 멈추라면 기다리고, 가라면 가는 ...

semaphore의 구성요소

- 변수 S : 사용 가능한 공유 자원의 **개수**를 나타내는 변수 (임계 구역에 진입할 수 있는 프로세스 수)
- wait() : 임계 구역 진입 전 호출하는 함수
- signal() : 임계 구역 진입 후 호출하는 함수

wait()함수

```
wait() {
	S --;			//1
	if (S < 0 ) { 		//2
		sleep();	//3
		} 
	}	
```
1. 사용 가능한 자원의 개수 S를 1 감소
2. S가 0보다 작은지 확인, 공유 자원이 남아있는지 확인
만약, 0이랑 같거나 클 때에는 wait()을 호출한 프로세스 및 스레드는 ciritical section으로 들어간다.

만약, 0보다 작은 경우에는 S가 0이었음을 의미하므로 가능한 공유자원의 개수가 남아있지 않다. 
따라서, wait()을 호출한 프로세스 및 스레드는 **대기 상태로 전환**되어, 임계 구역에 진입하지 못 한다. 

signal() 함수

```
signal() {
	S ++;			//1
	if (S >= 0 ) {		//2
		wakeup(p);	//3
	}
}
```

1. signal() 함수가 시작되면, S 하나 증가
2. 
만약 S가 0 이상이라면, 증가하기 전 값은 0 이상, 즉 대기 중인 프로세스, 스레드는 없다. 그렇기에 continue
만약 S가 0 미만이라면, 증가하기 전 값은 0 미만, 즉 대기 중인 프로세스, 스레드가 있다! (why? 아까 wait()함수에서 S -- 하고 처리는 안했어
3. 대기상태의 P 하나를 준비상태로 전환


> Semaphore는 크기 Binary와 Counting 두개. 지금까지는 Counting Semaphore로 공유 자원이 여러개 존재하는 경우에 사용 가능한 Semaphore. Binary Semaphore는 S가 0/1 값을 가지는 Semaphore이다. 이는 거의 mutex와 비슷하게 작동한다. 그렇기에 Semaphore라고 하면 보통 Counting Semaphore이다. 


### 모니터링

조건변수(condition variable) = 실행 순서 제어를 위한 동기화 도구, 특정 조건 하에 프로세스 실행/일시 중단 함으로써 프로세스나 스레드의 실행 순서를 제어한다. 
- wait()함수 호출 : 호출한 프로세스 및 스레드의 상태를 **대기 상태로 전환**
- signal() 함수 호출: wait()으로 인해 일시 중지된 프로세스, 스레드의 실행을 재개하는 함수

조건변수 실행 예제 코드

```
public class CV {
	private static final Lock lock = new ReentrantLock();
	private static final Condition cond = lock.newCondition();
	private static boolean ready = false;

	public static void main(String[] args) throws InterruptedException {
	Thread t1 = new THread(new ThreadJob1());
	Thread t2 = new Thread(new ThreadJob2());

	t1.start();
	t2.start();

	t1.join();
	t2.join();
}

static class ThreadJob1 implements Runnable { 

	@Override
	public void run(){
		
		// p1 먼저 시작
		lock.lock();
		try{
			//p2 대기
			while (!ready) {
				cond.await(); //조건 변수 wait()
				}
			}catch (InterruptedException e) {
				e.printStackTrac();
			}finally{
				lock.unlock();
		}
		//p1다시 시작
		sout p1 종료 


static class ThreadJob2 implements Runnable {
	@Override
	public void run(){
		
		sout p2 2초 실행 시작
		lock.lock();
		try{
			Thread.sleep(2000);	//2초 대기
			while (!ready) {
				cond.await(); //조건 변수 wait()
				}
			}catch (InterruptedException e) {
				e.printStackTrac();
			}finally{
				lock.unlock();
			try{
				ready = true;
				cond.signal();
			}finally{
				lock.unlock();
}}}}
```
ㅔㅎ 182
		}
		//p1다시 시작
		sout p1 종료 
	
