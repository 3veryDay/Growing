## CPU 스케줄링


운영체제는 **CPU scheduling에 따라서 CPU를 배분하고, CPU 스케줄링 알고리즘은 이러한 CPU 스케줄링의 절차이며 CPU 스케줄링 알고리즘을 결정하고 수행하는 OS의 일부를 CPU scheduler라고 한다.
>실행의 문맥이 있다면 모두 스케줄링의 대상(프로세스 + 스레드 ...)

##### Priority = 우선순위
운영체제는 **프로세스 별** priority를 판단해서 **PCB**에 명시, 우선순위가 높은 프로세스에는 CPU의 자원을 더 빨리, 많이 할당한다. 
`ps` 명령어를 통해서 프로세스의 우선순위를 확인 할 수 있음

운영체제가 프로세스의 priority를 결정하는 기준
1. CPU Utilization = CPU 활용률 : 전체 CPU 가동 시간 중 작업을 처리하는 시간의 비율
   - CPU 활용 시간 = CPU burst + I/O burst
   - CPU burst : 프로세스가 CPU를 이용하는 작업
   - I/O burst : 입출력 장치를 기다리는 작업
   - 프로세스마다, cpu burst와 I/O burst 시간의 양에는 차이가 있다.
     - I/O bound process = 입출력 집중 프로제스 : 비디오 재생 디스크 백업 작업 등 I/O burst가 많음
     - CPU bound process = CPU 집중 프로세스 : 복잡한 수학 연산, 그래픽 처리 작업 등은 CPU burst가 많음
    
     - I/O bound process는 입출력을 위한 대기 시간이 매우 많고, CPU bound process는 실행 상태에 많이 머무른다.
     - 그렇기에
     - **IO burst process를 가능한 빨리 실행시켜서 끊임없이 입출력 장치를 작동시킨 후, CPU burst process에 집중적으로 CPU 할당을 한다**
     - 입출력 집중 프로세스는 CPU 집중 프로세스보다 우선순위가 높다.
     - 이는 상황에 맞게 CPU를 배분하는 것이 효과적이기에 이렇다.

##### Scheduling queue
CPU를 이용하고 싶은 프로세스의 PCB와 메모리로 적재되고 싶은 프로세스의 PCB, 특정 입출력 장치를 이용하고 싶은 프로세스의 PCB를 큐에 삽입시켜서 줄을 세우는 것

대표적으로 ready queue(준비 큐)와 waiting queue(대기 큐)가 있음
- ready queue: CPU를 이용하고 싶은 프로세스의 PCB의 줄
- waiting queue : 대기 상태에 접어든 프로세스의 PCB의 줄

주로 입출력 작업을 수행중일 때, 대기 큐에서 대기 상태로 입출력 완료 인터럽트를 기다리게 됩니다.
준비 상태인 프로세스의 PCB는 준비 큐의 마지막에 삽입되어서 CPU 차례를 기다린다. 
운영체제는 큐에 삽입된 순서에 따르되, 우선순위가 높은 프로세스부터 먼저 실행한다. 
실행되는 프로세스가 할당받은 시간을 모두 소모하면 (timer interrupt) 준비 큐로 다시 이동
실행 도중 입출력 작업을 수행하는 등 대기 상태로 접어 들어가야 하는 경우 대기 큐로 이동하게 된다.
![image](https://github.com/user-attachments/assets/99533ea0-e959-4ceb-94f9-6327616b23f5)
- 같은 입출력 장치를 요구한 프로세스들끼리는 같은 대기 큐에서 기다림. 
- 입출력 끝나면 완료 인터럽트가 발생해서, 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고
- 이 PCB를 준비 상태로 변경한 뒤, 대기 큐에서 제거한다.

##### 선점형 스케줄링과 비선점형 스케줄링

기본적으로 스케줄링은 프로세스의 실행이 끝나면 이루어지지만 실행상태에서 입출력 작업을 위해서 대기 상태로 전환될 때, 그리고 실행 상태에서 타이머 인터럽트가 발생할 2가지 상황에서는 프로세스가 종료되지 않았어도 스케줄링이 수행된다.

선점형 스케줄링 : 입출력 작업을 위해 대기 상태로 전환 + 타이머 인터럽트
- **운영체제가 프로세스로부터 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링**
- 장점 : 한 프로세스의 독점을 막고, CPU 자원의 공정한 배분
- 단점 : 문맥 교환 과정에서의 오버헤드가 발생

비선점형 스케줄링 : 입출력 작업을 위해 대기 상태로 전환
- 다른 프로세스가 무조건 기다려야 함.
- 장점 : 문맥 교환 횟수가 적기에 오버헤드가 적게 발생
- 단점 : 모든 프로세스가 대기



### CPU 스케줄링 알고리즘

운영체제가 CPU를 프로세스에게 배분하는 방법 7가지, 장단점

1. FCFS
   ready queue에 삽입된 순서대로 처리. - **비선점형**

   단점 : 프로세스 대기 시간이 매우 길 수도
   **Convoy Effect**(호위 효과) : 먼저 삽입된 프로세스의 매우 긴 실행 시간으로 나중에 삽입된 프로세스의 실행이 지연되는 문제

2. SJF
   CPU 이용 시간이 매우 짧은 프로세스부터 - **비선점형**

   **기본적으로 비선점형이지만 '최소 잔여 시간 우선 스케줄링'은 선점형으로 구현**

3. RR
   큐에 삽입된 프로세스들이 삽입된 순서대로 CPU를 이용하지만, 정해진 슬라이스 만큼만 사용 - **선점형**
   FCFS + time slice
   Time slice : 프로세스가 CPU를 사용하도록 정해진 시간

4. SRT(Shortest Remaining Time)
   정해진 타임 슬라이스만큼 CPU 이용하되, 남아있는 작업 시간이 가장 적은 프로세스를 다음으로 CPU를 이용한 프로세스로 선택 - **선점형**
   
   SJF + RR

5. Priority
   프로세스에 우선순위 부여, 가장 높은 우선순위부터 실행

   문제! : Starvation Problem(아사) : 우선순위가 낮아, 실행이 무한히 연기될 수도 있음
   해결! : Aging : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식

6. MultiLevel Queue(다단계 큐)
   Priority의 발전된 형태, 우선순위 별로 여러개의 준비 큐를 사용

   우선순위가 가장 높은 큐에 있는 프로세스 처리, 그 다음으로 우선순위가 높은 큐 처리
   단점 : Starvation Problem

7. MultiLevel **FEEDBACK** Queue
   위의 다단계 큐의 아사 현상을 보완한 방법으로 ,**프로세스들이 큐 사이를 이동할 수 있다**는 점에서 차이가 있다.

   비교적 CPU를 오래 사용해야 하는 **CPU 집중 프로세스**의 우선순위가 낮아지고, CPU를 적게 사용해야 하는 **입출력 집중 프로세스**들은 우선순위가 높은 큐에서 실행이 끝나게 된다.

   여기에 Aging을 더할수도!!


어라~ 근데 실제로는 하나만 쓰이지 않음!

### Linux CPU Scheduling

리눅스에서는 상황에 따라 스케줄링 알고리즘이 달라짐.

|스케줄링 정책 | 적용 상황 | 
| -- | -- | 
|SCHED_FIFO, SCHED_RR | 실시간성 프로세스에 적용되는 정책(매우 높은 우선순위를 할당함|
|SCHED_NORMAL|일반적인 프로세스에 적용되는 정책|
|SCHED_BATCH| 일반적인 프로세스만큼 자주 선점하지 않는 배치 작업에 적용되는 정책 | 
|SCHED_IDLE | 우선순위가 매우 낮은 프로세스에 적용되는 정책(매우 낮은 우선순위를 할당함 | 

SCHED_FIFO와 SCHED_RR 는 RT(REAL TIME) 스케줄러에 의해 이루어지는 스케줄링. - 실시간성이 강조된 프로세스

SCHED_NORMAL,에서는 CFS라는 CPU 스케줄러에 의해 스케줄링이 이루어짐
CFS : (COMPLETLY FAIR SCHEDULER) 공평한 시간 배분을 지향하는 CPU 스케줄러

리눅스에서는 프로세스마다 가상 실행 시간(VRUNTIME) = (Virtual Run Time)이라는 정보를 유지해서, 이것이 작은 프로세스부터 실행한다. 
VrunTime은 실제로 실행되는 runtime이 아닌 **프로세스의 가중치**를 고려한 **가상의 실행 시간**
여기서 가중치는 프로세스의우선순위랑 비슷하기에, 이가 높아질수록 가중치도 높아진다. 


   



