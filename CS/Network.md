# 🌐 기술 인터뷰 대비: 네트워크 & 백엔드 통합 노드

## 📌 목차
1. **Network 기본 지식**
   - 병목(Bottleneck) 현상과 대기열 관리
   - 네트워크 진단 명령어 (ping, netstat 등)
2. **CS Network (전송 및 인터넷 계층)**
   - TCP vs UDP의 특성과 효율성
   - IP 주소 할당 방식 (정적 IP vs 동적 IP)
   - Keep-Alive(TCP vs HTTP)
3. **CS 핵심 개념 (인프라 및 주소)**
   - IP 변환 및 자동 할당 (NAT & DHCP)
   - 콘텐츠 전송 최적화 (CDN)
4. **HTTP & Web Security (프로토콜과 상태 유지)**
   - HTTP 메서드 종류 및 멱등성
   - 상태 유지 기법 (Cookie, Web Storage)
   - 인증 및 확장성 (Session vs JWT)
   - 보안 프로토콜 (HTTPS/TLS)
   - CORS란?
5. **Spring Integration (실무 구현)**
   - Spring Security 기반 인증/인가 구현
   - Spring Web Mapping과 보안 고려사항

---

## 1. Network 기본 지식

### Q) 병목(Bottleneck) 현상과 그 해결책은 무엇인가요?
* **개념:** 전체 시스템 성능이 특정 요소(네트워크 대역폭, 서버 리소스 등)로 인해 제한받는 현상입니다.
* **해결 전략:** 트래픽이 몰리는 지점에 로드밸런서를 배치하거나, **대기열 서버(Queue Server)**를 두어 메인 서버에 가해지는 부하를 순차적으로 처리하도록 설계합니다.

### Q) 네트워크 장애 시 명령어창에서 무엇을 확인할 수 있나요?
* **ping:** 대상 IP/도메인과의 연결성을 ICMP 프로토콜로 확인합니다.
* **netstat:** 현재 서버에 연결된 소켓 상태와 포트 개방 여부를 확인합니다.
* **nslookup:** DNS 서버를 통해 도메인 명에 매핑된 IP 주소를 조회합니다.
* **tracert:** 패킷이 목적지까지 가는 경로상의 지연 지점을 파악합니다.

---

## 2. CS Network (전송 및 인터넷 계층)

### Q) TCP와 UDP의 차이와 효율성에 대해 설명해주세요.
* **TCP:** 3-way handshake를 통해 신뢰성 있는 연결을 수립합니다. 데이터 순서와 전송을 보장하지만 헤더가 무겁습니다.
* **UDP:** 핸드쉐이크 과정이 없어 **오버헤드가 적고 효율적**입니다. 
    * **오류 검출:** 체크섬(Checksum) 필드로 최소한의 무결성만 확인하며, 신뢰성보다 속도가 중요한 실시간 서비스에 적합합니다.


### Q) 정적 IP와 동적 IP의 할당 방식 차이는?
* **정적(Static) IP:** 사용자가 직접 IP, 게이트웨이 등을 고정 설정합니다. 서버 운영 시 주로 사용합니다.
* **동적(Dynamic) IP:** **DHCP** 프로토콜을 통해 접속 시마다 자동으로 IP를 할당받습니다. 관리가 효율적이며 일반 클라이언트 기기에서 사용됩니다.


### Q) Keep-Alive란 무엇이며, TCP와 HTTP에서 각각 어떻게 작동하나요?
- 정의: 이미 연결된 커넥션을 끊지 않고 재사용하여 연결 수립 비용을 줄이는 기술입니다.

- HTTP Keep-Alive: * 목적: 하나의 TCP 연결을 통해 여러 개의 HTTP 요청/응답을 주고받기 위함입니다 (Persistent Connection).

   - 작동: HTTP/1.1부터 기본이며, 헤더에 Connection: keep-alive를 명시합니다. 매번 3-way handshake를 하지 않아 성능이 향상됩니다.

- TCP Keep-Alive: * 목적: 연결된 두 종단 사이의 연결이 여전히 유효한지(Liveness)를 확인합니다.

   - 작동: 데이터 교환이 없는 유휴 상태일 때, 아주 작은 탐사 패킷을 보내 상대방의 응답을 확인합니다. 응답이 없으면 끊어진 연결로 판단하고 자원을 회수합니다.
---

## 3. CS 핵심 개념 (인프라 및 주소)

### Q) NAT와 DHCP에 대해 설명해주세요.
* **NAT (Network Address Translation):** 사설 IP를 공인 IP로 변환하여 주소 부족 문제를 해결하고 내부 네트워크 보안을 강화합니다.
* **DHCP:** 네트워크 내 기기들에게 자동으로 IP 주소를 대여해주고 회수하는 관리 프로토콜입니다.

### Q) CDN(Content Delivery Network)의 개념과 사용처는?
* **개념:** 지리적으로 분산된 서버 네트워크입니다.
* **목적:** 사용자에게 물리적으로 가까운 **Edge Server**에서 콘텐츠를 제공하여 로딩 속도를 줄이고 메인 서버의 부하를 줄입니다.

---

## 4. HTTP & Web Security (프로토콜과 상태 유지)

### Q) HTTP 메서드 종류와 멱등성에 대해 설명해주세요.
* **GET:** 조회. (멱등성 O) *참고: GET은 본문을 가질 수 있으나 표준상 권장되지 않음.*
* **POST:** 생성. (멱등성 X)
* **PUT:** 전체 교체. (멱등성 O)
* **PATCH:** 일부 수정. (멱등성 X - 설계에 따라 다를 수 있음)
* **DELETE:** 삭제. (멱등성 O)
* **TRACE:** 보안 위협(XSS 등) 가능성으로 실제 운영 시 차단하기도 합니다.

### Q) 쿠키의 종류와 웹 스토리지의 차이는 무엇인가요?
* **Cookie:** 서버와 연동되며, 옵션으로 보안을 강화합니다.
    * **세션 쿠키:** 브라우저 종료 시 삭제. / **영속 쿠키:** 지정 기한까지 유지.
    * **보안 옵션:** `Secure`(HTTPS만), `HttpOnly`(JS 접근 차단), `SameSite`(CSRF 방지).
* **Web Storage:** 서버로 전송되지 않아 쿠키보다 더 많은 데이터를 저장할 수 있습니다.
    * **Local Storage:** 직접 삭제 전까지 영구 유지.
    * **Session Storage:** 탭/브라우저를 닫으면 즉시 삭제.

### Q) 세션 방식과 JWT 방식의 차이 및 선택 기준은?
* **Session:** 서버 메모리/DB에 상태를 저장합니다. 보안 통제가 용이하지만, 서버 확장 시 **세션 동기화** 비용이 발생합니다.
* **JWT (Self-signed Token):** 토큰 자체가 인증 정보를 포함합니다. 
    * **분산 환경:** 서버가 여러 대여도 상태 정보를 공유할 필요가 없어 **MSA/확장성**에 매우 유리합니다. 서버는 비밀키로 무결성만 검증하면 됩니다.

### Q) HTTPS의 SSL/TLS 암호화 과정은?
* **Handshake:** 비대칭키 방식을 사용하여 서버 신원을 확인하고 **대칭키(세션키)**를 안전하게 교환합니다.
* **Data Transfer:** 실제 본문 데이터는 연산 속도가 빠른 대칭키를 사용하여 암호화합니다.

### Q) CORS란?

* 정의 : 브라우저가 자신의 출처(Origin)와 다른 출처의 리소스에 접근할 수 있도록 허용하는 정책
* 배경 : 기본적으로 브라우저는 보안을 위해서 SOP(Same Origin Policy)를 따르지만, 현대 웹은 API 서버와 프론트엔드 서버가 다른 경우가 많아서 CORS가 필수임.
* 작동방식 : 브라우저가 실제 요청 전 OPTIONS 메서드를 사용하는 preflight 요청을 보내 서버가 허용하는 출처인지 확인한다.
1. preflight요청
- OPTIONS라는 메서드를 사용해서 서버에 미리 요청을 보냄
- 헤더에 Origin(나 누구야)와 ACess-Control-Request-Method 담아서 보냄.

2. 서버의 응답
- 서버는 이 요청(preflight)를 받고 자신의 whitelist확인함
- 허용되면, 응답 해더에 Access-Control-Allow-Origin:http//my-front.con울 담아서 보냄

3. 실제 요청
- 브라우저가 서버의 허락을 확인하고 데이터를 요청한다.


* (이때 SOP는 프로토콜, 호스트, 포트가 같아야 함)

---

## 5. Spring Integration (실무 구현)

### Q) 프로젝트에서 인증과 인가를 어떻게 구현했나요?
* **구현:** `Spring Security` 프레임워크를 도입하여 처리했습니다.
* **인증(Authentication):** ID/Password 기반 혹은 OAuth2를 통한 신원 확인을 수행했습니다.
* **인가(Authorization):** 인증 성공 후 서버에서 **JWT**를 발급하였고, 이후 요청마다 필터(`OncePerRequestFilter`)에서 토큰의 서명을 확인하여 권한을 부여했습니다.

### Q) Spring Web Mapping 사용 시 보안 고려사항은?
* **@GetMapping:** 단순 조회에 사용하되, 보안이 필요한 데이터는 쿼리 스트링 노출을 방지하기 위해 POST 바디 사용을 검토합니다.
* **Filter Chain:** 컨트롤러 진입 전 보안 필터 단계에서 인가되지 않은 접근을 차단하여 비즈니스 로직을 보호합니다.

### Q) 프로젝트에서 CORS 어떻게 함?
- 답변 전략 (Spring Security 연동): "단순히 @CrossOrigin 어노테이션을 쓸 수도 있지만, 저는 Spring Security를 사용 중이었기 때문에 SecurityFilterChain 설정 내에서 공통적으로 관리했습니다."

- 구현 방식:

   - CorsConfigurationSource 빈을 생성하여 허용할 Origin, Method, Header를 정의했습니다.

   - 프론트엔드 배포 주소(예: https://myapp.com)와 로컬 개발 주소만 허용하도록 화이트리스트를 작성했습니다.

   - http.cors(cors -> cors.configurationSource(corsConfigurationSource())) 설정을 통해 Security 필터 단계에서 CORS 처리가 먼저 이루어지도록 적용했습니다.

Q) 프로젝트 로그인(인증/인가) 구현 방식은?
- 인증: Spring Security의 AuthenticationManager를 거쳐 DB의 사용자 정보와 일치하는지 확인했습니다.

- 인가: 인증 성공 시 서버의 비밀키로 서명된 JWT를 발급했습니다. 이후 모든 요청의 Authorization 헤더에 담긴 토큰을 필터에서 검증하여 권한을 부여했습니다.

--- 

추가 공부할 내용

### 🌐 기술 인터뷰 심화: SOP와 CORS의 핵심 원리

---

#### 1. SOP (Same-Origin Policy): 브라우저의 최소 보안 장치
SOP는 "동일 출처 정책"으로, 브라우저가 사용자(클라이언트)를 보호하기 위해 만든 가장 기본적인 보안 규칙입니다.

* **정의:** 어떤 출처(Origin)에서 불러온 문서나 스크립트가, 다른 출처의 리소스와 상호작용하는 것을 제한하는 정책입니다.
* **비유:** 우리 집(사이트 A)에 방문한 손님(스크립트)이 우리 집 물건만 만질 수 있게 하고, 옆집(사이트 B) 금고를 열어보지 못하게 막는 것과 같습니다.
* **필요성:** 만약 이 정책이 없다면, 악성 사이트에 접속하는 것만으로도 브라우저에 저장된 사용자의 다른 사이트 로그인 쿠키가 탈취되어 개인정보가 유출될 수 있습니다.



---

#### 2. CORS (Cross-Origin Resource Sharing): 안전한 예외 허용
CORS는 SOP라는 엄격한 규칙 때문에 웹 개발이 불가능해지는 것을 막기 위해, 서버가 "이 사이트는 안전하니 정보를 줘도 된다"고 명시적으로 허락하는 메커니즘입니다.

* **핵심 질문:** "클라이언트를 보호하는데 왜 서버가 화이트리스트를 관리하나요?"
* **답변:** 서버의 데이터를 **어떤 외부 사이트(Origin)가 가져가도 안전한지**는 서버 주인만이 알기 때문입니다. 서버가 "이 리소소는 저 사이트가 가져가도 돼"라고 브라우저에게 알려주면, 브라우저는 안심하고 정보를 전달합니다.

---

#### 3. CORS 작동 방식: 브라우저와 서버의 대화 (Preflight)
실제 데이터를 보내기 전, 브라우저는 서버에 **OPTIONS** 메서드를 사용하여 예비 요청을 보냅니다.

1. **브라우저 (경찰):** "서버님, 지금 `https://bad-hacker.com`에서 당신네 API를 쓰겠대요. 얘 허락된 애인가요?"
2. **서버 (주인):** (화이트리스트 확인 후) "아니, 걔는 모르는 애야. 내 응답 헤더엔 걔 주소가 없어."
3. **브라우저 (경찰):** "알겠습니다. 서버님이 데이터를 보내주셨더라도, 제가 중간에서 차단해서 악성 사이트가 읽지 못하게 하겠습니다."



---

#### 4. CORS와 인증(JWT/세션)의 차이점
이 두 가지는 목적지가 다른 두 개의 관문입니다.

| 구분 | CORS (교차 출처 리소스 공유) | 인증/인가 (JWT, Session) |
| :--- | :--- | :--- |
| **보호 대상** | **사용자(브라우저)** | **서버(데이터 리소스)** |
| **목적** | 악성 사이트가 사용자 권한을 도용하는 것 방지 | 신뢰할 수 있는 사용자인지 확인 |
| **비유** | 어느 동네 사람이 우리 집에 오는지 통제 | 우리 집 들어온 사람의 신분증 검사 |



---

#### 5. 실무에서의 트러블슈팅 및 요약
* **서버의 책임:** 서버는 응답 헤더(`Access-Control-Allow-Origin`)에 허용된 출처를 정확히 적어주어야 합니다.
* **브라우저의 책임:** 서버가 허용하지 않은 출처라면, 서버로부터 온 응답을 자바스크립트가 접근하지 못하도록 폐기합니다.
* **결론:** CORS는 서버 보호 도구가 아니라, **서버가 브라우저에게 "이 클라이언트는 안전하다"고 보증해주는 약속**입니다. 이를 통해 브라우저는 사용자의 데이터를 안전하게 지키면서도 필요한 리소스를 공유할 수 있습니다.

---

### 💬 면접용 핵심 답변 (One-liner)
"CORS는 서버의 보안 설정이 아니라, **서버가 브라우저에게 특정 출처의 접근을 허용한다고 알려줌으로써 사용자를 보호하는 브라우저의 정책**입니다. 서버는 화이트리스트 설정을 통해 어떤 사이트가 자신의 데이터를 읽을 수 있는지 결정하며, 브라우저는 이 설정을 근거로 데이터를 전달하거나 차단합니다."
