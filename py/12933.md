## 🚀 이슈 번호

**Resolve:** {#1513}

## 🧩 문제 해결

**스스로 해결:** ✅

### 🔎 접근 과정

> 문제 해결을 위한 접근 방식을 설명해주세요.

- 🔹 **어떤 알고리즘을 사용했는지** : ?? 정렬 ?? 그리디 ??
- 🔹 **어떤 방식으로 접근했는지** : 테스트 케이스가 부족해서 문제를 이해하는 것이 어려웠습니다. 울다 만 경우에 어떻게 처리해야 하는지, 등의 설명이 부족했기에 문제를 푸는 데 어려움이 있었습니다.
  - 처음에는 quack이 몇번 나오는지 세는 문제로 오해를 해서, idx 만으로 순회하면서 quack을 순서대로 셌지만, 문제는 그게 아니었기에 처음부터 다시 풀었습니다.
  - 소리를 현재 내고 있는 오리를 관리하는 deque인 quacking_duck과, 소리를 내다가 멈춰서 다시 소리를 낼 수 있는 오리를 관리하는 deque인 waiting_duck 배열을 사용했습니다. 추가로 [오리번호] = 낸 마지막 소리 idx를 관리하는 duck_arr 배열도 사용했습니다. 
  - 총 소리인 sound를 한번만 순회하면서 'q' 를 만났을 경우, waiting_duck이 없으면 새로운 duck을 추가하도록 했고, waiting_duck이 있으면 pop을 해서, 새로운 duck을 추가하지 않고 진행하도록 했습니다.
  - q가 아닌 다른 알파벳을 만났을 경우에, 만약 quacking_duck(소리를 내고 있는 오리)가 없으면 바로 -1을 출력하도록 했고, quacking_duck이 있다면, quacking_duck을 순회하면서, 가능한 오리를 찾도록 했습니다. (이때가능한 오리가 없으면 -1 출력)
  - 이런 식으로 sound을 한번 순회하고, 마지막에 duck_arr에서 중간에 끊긴 오리가 있다면(value가 4가 아닌 경우)는 -1 출력, 아닌 경우에는 duck_arr의 길이(-1) 을 출력하도록 했습니다. 

### ⏱️ 시간 복잡도

> **시간 복잡도 분석을 작성해주세요.**  
> 최악의 경우 수행 시간은 어느 정도인지 분석합니다.

- **Big-O 표기법:** `O(Slog(S))`
- **이유:** : 한번만 순회하면서 안에서 최대 log(S)만큼 추가로 순회

## 💻 구현 코드

```python
import sys
from collections import deque
input = sys.stdin.readline

sound = list(input().strip())
s = len(sound)

quack = ['q', 'u', 'a', 'c', 'k']

waiting_duck = deque()
quacking_duck = deque()
duck_arr = [-1] # [오리번호] = 끝난 idx


for idx in range(s) :
    # q 마주친 경우
    if sound[idx] == 'q' :
        # 기다리는 오리가 없는 경우 
        if not waiting_duck :
            # 새로운 오리 추가
            quacking_duck.append(len(duck_arr))
            duck_arr.append(0)
        # 기다리는 오리가 있는 경우
        else :
            duck = waiting_duck.popleft()
            quacking_duck.append(duck)
            duck_arr[duck] = 0
        continue
    
    # q가 아닌 다른 문자를 마주친 경우


    # 근데 소리내는 오리가 없는 경우
    if not quacking_duck :
        print(-1)
        exit()
    # 소리내는 오리가 있는 경우
    else :
        flag = True
        for duck in list(quacking_duck) :
            if sound[idx] == quack[(duck_arr[duck] + 1 )%5]:
                flag = False
                duck_arr[duck] += 1
              
                # quack 끝난 경우
                if duck_arr[duck] == 4 :
                    waiting_duck.append(duck)
                    quacking_duck.remove(duck)
                break
        # 소리 내고 있는 오리 중에서 다음 sound를 낼 수 있는 오리가 없는 경우 -> sound[idx] = C인데, 오리들은 q, quac 이런 소리 냈을 경우 
        if flag :
            print(-1)
            exit()
            
for tmp in range(1, len(duck_arr)) :
    # 오리 중 중간에 소리가 끊긴 오리가 있는 경우
    if duck_arr[tmp] != 4 :
        print(-1)
        exit()
# 모두다 소리를 잘 낸 경우, 처음에 추가했던 idx=0 제외하고 출력
print(len(duck_arr)-1)

```
