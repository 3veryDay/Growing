## 🚀 이슈 번호

**Resolve:** {#1512}

## 🧩 문제 해결

**스스로 해결:** ❌

### 🔎 접근 과정

> 문제 해결을 위한 접근 방식을 설명해주세요.

- 🔹 **어떤 알고리즘을 사용했는지** : BruteForce
- 🔹 **어떤 방식으로 접근했는지** : 처음에는 간단 수식으로 통해서 최대 곡 수를 구하고, BFS로 최소 기타 개수를 구하도록 했지만, 로직에서 오류가 많이 발생해, 정답을 구할 수 없었습니다.
- 그래서, 정답을 참고했습니다. 비슷한 방식으로, 근데 모든 조합을 탐색하는 BruteForce로 문제를 풀 수 있었습니다.
  - 기타를 1개 이상 고른 모든 조합을 itertools의 combination을 통해서 구합니다.
  - 조합이 연주할 수 있는 곡들을 합집합으로 구하고 `|=`, 이 합집합의 크기가 (0으로 초기화했던)지금까지 연주할 수 있었던 곡의 최대값보다 크면, 갱신하는 방식으로 코드를 짰습니다.
  - 그리고, 만약 연주할 수 있는 곡이 지금까지 연주할 수 있었던 곡의 최대값과 동일하다면, 기타 수를 더 작은 값으로 갱신하는 방식으로 코드를 짰습니다.

### ⏱️ 시간 복잡도

> **시간 복잡도 분석을 작성해주세요.**  
> 최악의 경우 수행 시간은 어느 정도인지 분석합니다.

- **Big-O 표기법:** `O(2*N)`
- **이유:**

## 💻 구현 코드

```python
from itertools import combinations

N, M = map(int, input().split())
guitars = []

for _ in range(N):
    name, songs = input().split()
    playable = {i for i, ch in enumerate(songs) if ch == 'Y'}
    guitars.append(playable)

max_song = 0       # 연주 가능한 최대 곡 수
min_guitar = 11    # 최소 기타 개수

# 1개 이상 모든 조합 탐색
for r in range(1, N+1):
    for comb in combinations(guitars, r):
        combined = set()
        for g in comb:
            combined |= g   # 합집합 **** 중요! 
        song_cnt = len(combined)  # 연주 가능 곡 수

        if song_cnt > max_song:
            max_song = song_cnt
            min_guitar = r
        elif song_cnt == max_song:
            min_guitar = min(min_guitar, r)

# 연주할 수 있는 곡이 하나도 없으면 -1
print(-1 if max_song == 0 else min_guitar)
```
