📌 문제 해결을 위한 질문들

2. 정렬과 그리디 전략

폭격 미사일을 어떤 기준으로 정렬하는 것이 최소 요격 미사일을 찾는 데 가장 적합할까?

### 신기방기 정렬에 따라서 달라지는 시간 복잡도


|targets.sort()|targets.sort(key = lambda x : (x[0]+x[1]) |targets.sort(key = lambda x : x[1]) | targets.sort( -1) & bound는 변수|
|--------|--------|--------|-----------|
|1287ms|571ms|480ms|390ms|

- 정렬에 따라서 시간 복잡도가 많이 차이 나는 건 어디서나 비슷하지만, GREEDY ALGORITHM에서는 더욱 극명하게 나타난다.
- Greedy Algorithm은 매 선택을 최적의 선택을 하는 건데, 정렬을 하는 기준은 **가능한 많은 구간을 한번에 처리**하자. 를 중요시 해야 해
- 빨리 끝나는 미사일들을 처리하면, 그 뒤에 겹치는 미사일들은 처리하지 않아도 되기 때문
- 요격 범위가 넓어지면, 그리디 때 선택하는 요소의 범위가 넓으면, 다음을 처리할 떄, 또는 겹치는 요소를 처리할 때 비효율적임/
- 끝나는 시간이 빠른 걸 빨리 처리해야함



정렬된 후, 미사일을 하나씩 처리하면서 현재 요격 미사일이 커버할 수 있는 범위를 어떻게 유지할 것인가?
미사일을 처리하면서 기존 요격 미사일의 범위를 업데이트해야 할 때, 어떤 기준으로 갱신해야 할까?
3. 요격 미사일 추가 조건
새로운 폭격 미사일이 기존 요격 범위에 포함되는 경우와 포함되지 않는 경우를 어떻게 구분할 수 있을까?
만약 새로운 폭격 미사일이 기존 요격 범위를 벗어난다면, 새로운 요격 미사일을 추가해야 하는데, 이때 기준이 되는 값은 무엇인가?
기존 요격 미사일의 범위를 유지하는 게 좋을까, 줄이는 게 좋을까? (예: bound[-1] > e 인 경우)
4. 코드 최적화
현재 코드에서 bound 리스트를 유지하고 있지만, 이를 리스트가 아닌 단순한 변수로 대체할 수 있을까?
pop() 연산이 꼭 필요한가? 없어도 되도록 개선할 수 있을까?
현재 코드에서 불필요하게 중복해서 요격 미사일을 추가하는 부분이 있는가? 있다면 어떻게 최적화할 수 있을까?
최종적으로 answer - len(bound) + 1을 리턴하는데, 이것이 정말 정확한 방식인가?
