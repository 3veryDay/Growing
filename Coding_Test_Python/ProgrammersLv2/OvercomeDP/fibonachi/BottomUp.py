def solution(n) : 
    dp = [-1] * ( n+1)
    dp[0] = 0
    dp[1] = 1
    dp[2] = 1
    for i in range(3, n+1) :
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

"""
이건 조금 쉬웠다.
왜겠어. 똑같은 문제를 지금 3번째 풀고 있는데...

이렇게 접근하는 걸 더 자주 한 것 같다.

여기서 차이점은 재귀를 사용하지 않기 때문에 오버플로우 문제가 발생하지 않는다.

Top Down 방식은 DP에서 재귀를 기반으로 문제를 해결하는 방식이다.
 - 재귀를 이용해서 필요한 값만 계산하지만, 재귀 호출을 반복적으로 하기 때문에 호출 스택(스택 오버플로우 발생 가능) 이 쌓이게 된다.

 장점
 - 직관적, 구현 쉬움
 - 점화식 그대로 옮길 수 있음

 단점 : 
 -재귀 스택, 스택 오버플로우 발생 가능성 있음
 - 오버헤드 존재

 Bottom Up 방식은 반복문 기반으로 문제를 해결한다.
 작은 문제부터 큰 문제까지 차근차근 해결하는 방식이다.

장점 
- 재귀 호출 오버헤드가 없어서 메모리 효율적이다.
- 안정적

단점 
- 모든 작은 문제가 계산되기 때문에, 불필요한 계산을 많이 할 수도 있다.

"""
