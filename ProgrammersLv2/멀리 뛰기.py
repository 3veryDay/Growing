"""
문제 설명
효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는
(1칸, 1칸, 1칸, 1칸)
(1칸, 2칸, 1칸)
(1칸, 1칸, 2칸)
(2칸, 1칸, 1칸)
(2칸, 2칸)
의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.

제한 사항
n은 1 이상, 2000 이하인 정수입니다.

생각의 흐름
재귀가 필요할 것 같았고, 그래서 dfs만을 처음에 생각.
dfs로는 안 풀리고, 런타임 에러가 날 것 같아서 dfs + 백트래킹을 생각

이렇게 몇시간을 했더니, runtime error와 함께
RecursionError: maximum recursion depth exceeded in comparison 와 같은 에러가 반복적으로 떴음.

1시간 정도 넘게 고민하고 나서, 답지를 찾아보니 이건 dp문제.
dp로 풀면 너무 쉽게 나오는 문제였고, 역시나 몇개를 미리 풀어보면 딱 보이는 구조였다.

성장 포인트.
1. 입력 문자가 하나 라면(두개까지라도) 일단 대입해서, 무슨 패턴이 보이는지 생각해보자.
2. 한 방향으로 문제가 안 풀리면, 그건 다른 방향을 생각해봐야 하는 것.

3. dp... 

"""
def solution(n) :
    answer = 0
    if n <=3 :
        return n
    dp = [0] * (n+1)
    
    dp[1] = 1
    dp[2] = 2
    dp[3] = 3
    for i in range(3,n+1) :
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n] % 1234567
