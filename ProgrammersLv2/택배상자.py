'''
굉장히 간단한 문제이지만, 시간 복잡도를 최적화해야지만 풀 수 있는 문제.
이러한 간단한 배열 문제에서 시간 복잡도를 줄일 수 있는 방법
1. [i for i in range(1, 29) ] 이러한 간단한 배열을 만들 거면, 차라리 그냥 I, I += 1 이런 식으로 숫자만 사용하는 것도 좋다.
2. 배열을 슬라이싱하거나, popleft 하는 것보다, index를 줄이거나 늘리는 식으로 하는 게 더 효율적이다.

if 어떠한 요소 in 배열 : -> 이거는 시간 복잡도 O(N)이다. 그렇기에 하나씩 썪여 있으면 시간 복잡도가 확 늘어난다.
그렇기 때문에, 특징이 있는 애들의 경우에는 바로 잡는 게 좋다. 
여기 같은 경우에는 순차적으로 box가 증가하기 때문에, order에 올 수 있는 애랑, 다른 벨트 위에 있는 친구들... 다 생각하면 굳이 in을 쓰지 않고, 간단하게 풀어 쓸 수 있었다.

'''


def solution(order) :
    
    sub = []
    l, o = 1, 0
    cnt = 0
    while o < len(order) and l <= len(order) + 1 :
        
        if l == order[o] :
            cnt += 1
            l += 1
            o += 1
        else :
            if not sub :
                sub.append(l)
                l += 1
                
            else :
                if sub[-1] == order[o] :
                    while sub and sub[-1] == order[o] and o < len(order) :
                        sub.pop()
                        o += 1
                        cnt += 1
                    sub.append(l)
                    l += 1
                else :
                    if sub[-1] > order[0] and order[o] < l :##if () in [] 이거 쓰면 확실히 확 늘어나서, 안 쓰는 게 좋다. 
                        return cnt
                    else :
                        sub.append(l)
                        l += 1

    return cnt


'''
너무 case by case으로 따졌더니 코드가 복잡해졌는데, 이처럼 간단하게 표현하기 위해서 어떤 연습을 해야할까?
'''

def solution(order):
    answer = 0
    stacks = []
    N = len(order)
    i = 1
    idx = 0
    while i < N+1:
        stacks.append(i)
        while stacks[-1] == order[idx]:
            idx += 1
            stacks.pop()
            if len(stacks) == 0:
                break
        i += 1


    return idx


'''
1️⃣ 핵심 패턴을 빠르게 찾아내는 연습
✅ 예제 코드를 분석하는 습관
지금 본 코드(stacks.append(i) → while stacks[-1] == order[idx])는 스택 자료구조를 자연스럽게 활용하는 패턴이야.
앞으로 비슷한 문제를 볼 때, "내가 아는 패턴 중 쓸 수 있는 게 있을까?" 라고 생각하면서 접근해 봐!
📌 연습 방법:

백준, 프로그래머스 같은 곳에서 스택을 활용하는 문제를 여러 개 풀어 보고, 공통적인 패턴을 정리해 봐.
예를 들어, "가장 최근에 추가한 값을 먼저 꺼내야 할 때 스택을 써야 한다!" 같은 원리를 기억해 두는 거야.
2️⃣ 불필요한 변수를 줄이는 연습
✅ "이 변수가 정말 필요한가?" 자문해 보기
네 코드에서는 l, o, cnt, condition 같은 변수가 많았어.
반면 위의 코드는 i, idx, stacks 정도로만 간결하게 유지됐어.
📌 연습 방법:

코드를 작성한 후 "이 변수가 없어도 동작할까?" 라고 질문해 보고, 한 번씩 제거해 보자.
같은 기능을 하는 다른 풀이를 찾아보면서, 어떤 변수를 생략했는지 비교하는 것도 좋은 방법이야.
3️⃣ while & if 문을 최소화하는 연습
✅ 조건문을 줄일 수 있는지 항상 고민하기
네 코드에서는 if - else가 여러 개 중첩되었지만,
위 코드는 while stacks[-1] == order[idx]를 활용해서 if 문을 줄였어.
while 내부에서 if len(stacks) == 0: break 같은 빠른 종료 조건도 깔끔하게 들어갔어.
📌 연습 방법:

문제를 풀 때, if-else 구조가 많아지면 "이걸 더 단순화할 방법이 없을까?" 라고 고민해 보기.
"반복문 내부에서 문제를 더 많이 해결할 수 있을까?" 라는 생각을 하면서 코드를 최적화해 보기.
4️⃣ 다른 사람의 코드 많이 분석해보기
✅ "내 코드 vs 다른 코드" 비교하는 습관
네 코드가 동작한다고 바로 넘어가지 말고, 다른 사람의 코드를 보면서 차이점을 분석하는 게 중요해!
"이 부분은 왜 이렇게 짰을까?" 하고 한 줄 한 줄 뜯어보면서 배우는 거야.
📌 연습 방법:

프로그래머스, 백준 같은 곳에서 내가 푼 문제의 베스트 풀이를 찾아본다.
내 코드와 비교하면서 개선할 부분이 있는지 분석한다.
다음번에 비슷한 문제를 풀 때, 배운 패턴을 적용해 본다.
5️⃣ 알고리즘 패턴을 정리해보기
✅ 자주 쓰이는 알고리즘 & 패턴 정리
스택, 큐, 정렬, DFS/BFS 같은 개념들을 직접 노트에 정리해 보면 좋아.
"이런 문제에서는 이런 패턴을 쓰면 좋다!" 하는 것들을 정리해 보면 나중에 코드가 더 간결해질 거야.
📌 연습 방법:

예를 들어, "스택을 활용하는 문제"를 풀 때 자주 나오는 패턴을 정리해 봐.
"스택의 top을 확인하는 방식이 중요하다."
"while 문을 활용해 연속적으로 pop하는 방식이 자주 나온다."
이렇게 패턴을 스스로 정리하면, 다음에 같은 유형의 문제를 볼 때 훨씬 빠르게 해결할 수 있어!
🔥 결론: 꾸준히 연습하고, 다른 코드 많이 보고, 패턴을 익혀라!
네가 지금처럼 계속해서 "더 간결하고 좋은 코드로 개선하려면 어떻게 해야 할까?" 고민하는 것 자체가 이미 엄청난 성장의 신호야! 👏👏
'''
